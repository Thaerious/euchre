import ast
import sys
from collections import defaultdict
from itertools import combinations

def get_local_imports(tree):
    """Extract local imports from the AST."""
    imports = []
    for node in ast.walk(tree):
        if isinstance(node, ast.ImportFrom):  # Relative import
            print(node.module)
            imports.append(node.module)
        elif isinstance(node, ast.Import):
            print(node)
            for alias in node.names:
                imports.append(alias.name)
        elif isinstance(node, ast.ImportFrom) and node.level > 0:  # Local relative import
            imports.append(node.module)
    return imports

class ContextRecord():
    def __init__(self):
        self.read = False
        self.write = False

    def __str__(self):
        if self.read and self.write: return "RW"
        if self.read: return "R"
        if self.write: return "W"

class AttrRecord(dict):
    """
    A record of attributes accessed by a method.
    """

    def add_reference(self, attribute:ast.Attribute):
        """
        Track operations on primitives.
        """
        if attribute.attr not in self:
            self[attribute.attr] = ContextRecord()

        context = type(attribute.ctx).__name__

        if (context == "Load"):
            self[attribute.attr].read = True
        elif (context == "Store"):
            self[attribute.attr].write = True

    def add_list_operation(self, node: ast.Call):
        """
        Track list-specific operations like append, extend, or slicing.
        """

        print(f"Add List Operation {node.attr} {node.parent.func.attr}")
        attr = node.func.attr

        if attr in {"append", "extend", "insert"}:  # Writing operations
            self.add_reference(node.func)
            self[node.func.attr].write = True
        elif attr in {"copy", "count", "index"}:  # Reading operations
            self.add_reference(node.func)
            self[node.func.attr].read = True

    def __str__(self):
        sb = ""
        for key in self:
            value = self[key]
            sb = sb + f" - {key} {str(value)}\n"

        return sb

class MethodRecord(dict):
    def add_reference(self, method:ast.FunctionDef, child:ast.Attribute):
        if method not in self: self[method] = AttrRecord()
        self[method].add_reference(child)

    def add_list_operation(self, method:ast.FunctionDef, child:ast.Call):
        if method not in self: self[method] = AttrRecord()
        self[method].add_list_operation(child)

    def __str__(self):
        sb = ""

        for key in self.keys():
            sb = sb + f"# {key}()\n"
            sb = sb + f"{(str)(self[key])}\n"

        return sb

class ClassCohesionAnalyzer(ast.NodeVisitor):
    def __init__(self):
        self.record = MethodRecord()
        self.current_method = None

    def visit_ClassDef(self, node):
        """Visit the class definition and process its methods."""

        for body_item in node.body:
            if isinstance(body_item, ast.FunctionDef):
                self.current_method = body_item.name
                self.visit(body_item)

    def visit_FunctionDef(self, node):
        """Visit a method definition."""

        if node.name != "foo": return
        print(f"Visit {node.name}")

        for child in ast.walk(node):
            # print(child)
            if is_attr(child):
                self.record.add_reference(self.current_method, child)

            if is_call(child):
                print(ast.dump(child, indent = 4)) 
                print(isinstance(child.func.value.value, ast.List))

class TypeFinder(ast.NodeVisitor):
    def visit_Assign(self, node):
        if isinstance(node.value, ast.List):
            print(ast.dump(node, indent=4))
        elif isinstance(node.value, ast.Dict):
            print(ast.dump(node, indent=4))          
        elif isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):
            if node.value.func.id == "set":
                print(ast.dump(node, indent=4)) 
            if node.value.func.id == "dict":
                print(ast.dump(node, indent=4))                 

def is_attr(branch):
    if not isinstance(branch, ast.Attribute): return False
    if not isinstance(branch.value, ast.Name): return False
    if not branch.value.id in {'self', 'this'}: return False
    return True

def is_call(branch):
    if not isinstance(branch, ast.Call): return False    
    if not isinstance(branch.func, ast.Attribute): return False
    if not isinstance(branch.func.value.value, ast.Name): return False
    if not branch.func.value.value.id in {'self', 'this'}: return False  
    return True

def assign_parents(tree):
    """
    Assign parent references to each node in the AST.
    """
    for node in ast.walk(tree):
        for child in ast.iter_child_nodes(node):
            child.parent = node

def invert_graph(graph):
    inverse = dict()

    for node, edges in graph.items():
        for edge in edges:
            if edge not in inverse: inverse[edge] = dict()
            inverse[edge][node] = graph[node][edge]

    return inverse

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python dependencies.py <path_to_python_file>")
        sys.exit(1)

    file_path = sys.argv[1]

    with open(file_path, "r") as file:
        code = file.read()

    tree = ast.parse(code)
    assign_parents(tree)

    analyzer = TypeFinder()    

    # analyzer = ClassCohesionAnalyzer()
    analyzer.visit(tree)

    # methods = analyzer.record
    # print(methods)
